import { getDueSchedules, markScheduleRun } from "@/actions/report-schedules";
import { db } from "@/db";
import { reportTemplates, systemSettings } from "@/db/schema";
import { sendEmailWithRetry } from "@/lib/email";
import { eq } from "drizzle-orm";
import { NextResponse } from "next/server";

const LOCK_KEY = "cron_process_reports_lock";
const LOCK_TIMEOUT_MS = 5 * 60 * 1000; // 5 minutes

/**
 * Acquire a simple lock using system_settings table
 */
async function acquireLock(): Promise<boolean> {
  const now = new Date();
  const existing = await db.query.systemSettings.findFirst({
    where: eq(systemSettings.key, LOCK_KEY),
  });

  if (existing) {
    const lockTime = existing.value as { lockedAt: string };
    const lockedAt = new Date(lockTime.lockedAt);
    const elapsed = now.getTime() - lockedAt.getTime();

    // If lock is still valid, can't acquire
    if (elapsed < LOCK_TIMEOUT_MS) {
      return false;
    }
  }

  // Acquire or update lock
  await db
    .insert(systemSettings)
    .values({
      key: LOCK_KEY,
      value: { lockedAt: now.toISOString() },
      updatedAt: now,
    })
    .onConflictDoUpdate({
      target: systemSettings.key,
      set: {
        value: { lockedAt: now.toISOString() },
        updatedAt: now,
      },
    });

  return true;
}

/**
 * Release the lock
 */
async function releaseLock(): Promise<void> {
  await db.delete(systemSettings).where(eq(systemSettings.key, LOCK_KEY));
}

/**
 * Generate a simple HTML report (placeholder for PDF generation)
 * In production, use @react-pdf/renderer for proper PDF generation
 */
function generateReportHtml(
  templateName: string,
  config: Record<string, unknown>
): string {
  const generatedAt = new Date().toLocaleString();

  return `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>${templateName}</title>
  <style>
    body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
    h1 { color: #333; border-bottom: 2px solid #0066cc; padding-bottom: 10px; }
    .meta { color: #666; font-size: 12px; margin-bottom: 20px; }
    .widget { border: 1px solid #ddd; padding: 15px; margin: 15px 0; border-radius: 8px; }
    .widget-title { font-weight: bold; margin-bottom: 10px; }
  </style>
</head>
<body>
  <h1>${templateName}</h1>
  <div class="meta">Generated: ${generatedAt}</div>
  <div class="content">
    ${
      Array.isArray(config.widgets)
        ? (config.widgets as Array<{ title?: string; type?: string }>)
            .map(
              (w) => `
          <div class="widget">
            <div class="widget-title">${w.title || "Widget"}</div>
            <p>Widget type: ${w.type || "unknown"}</p>
            <p><em>Full data available in PDF version</em></p>
          </div>
        `
            )
            .join("")
        : "<p>No widgets configured</p>"
    }
  </div>
  <footer style="margin-top: 40px; padding-top: 20px; border-top: 1px solid #eee; color: #666; font-size: 11px;">
    This report was automatically generated by FixIt CMMS.
  </footer>
</body>
</html>
`;
}

export async function GET(request: Request) {
  // Verify cron secret
  const cronSecret = request.headers.get("x-cron-secret");
  const expectedSecret = process.env.CRON_SECRET;

  if (!expectedSecret) {
    console.error("CRON_SECRET not configured");
    return NextResponse.json(
      { error: "Cron endpoint not configured" },
      { status: 500 }
    );
  }

  if (cronSecret !== expectedSecret) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  // Try to acquire lock
  const lockAcquired = await acquireLock();
  if (!lockAcquired) {
    return NextResponse.json(
      { message: "Another process is already running" },
      { status: 200 }
    );
  }

  try {
    // Get due schedules
    const dueSchedules = await getDueSchedules();

    if (dueSchedules.length === 0) {
      await releaseLock();
      return NextResponse.json({
        message: "No schedules due",
        processed: 0,
      });
    }

    const results: Array<{
      scheduleId: string;
      success: boolean;
      error?: string;
    }> = [];

    for (const schedule of dueSchedules) {
      try {
        // Get the template
        const template = await db.query.reportTemplates.findFirst({
          where: eq(reportTemplates.id, schedule.templateId),
        });

        if (!template) {
          console.warn(
            `Template ${schedule.templateId} not found for schedule ${schedule.id}`
          );
          await markScheduleRun(schedule.id, false, "Template not found");
          results.push({
            scheduleId: schedule.id,
            success: false,
            error: "Template not found",
          });
          continue;
        }

        // Generate report HTML
        const reportHtml = generateReportHtml(
          template.name,
          template.config as Record<string, unknown>
        );

        // Send email
        const emailResult = await sendEmailWithRetry({
          to: schedule.recipients as string[],
          subject: `Scheduled Report: ${template.name}`,
          html: reportHtml,
          text: `Your scheduled report "${template.name}" is attached. View this email in HTML format for full content.`,
        });

        if (emailResult.success) {
          await markScheduleRun(schedule.id, true);
          results.push({ scheduleId: schedule.id, success: true });
        } else {
          await markScheduleRun(schedule.id, false, emailResult.error);
          results.push({
            scheduleId: schedule.id,
            success: false,
            error: emailResult.error,
          });
        }
      } catch (error) {
        const errorMessage =
          error instanceof Error ? error.message : "Unknown error";
        console.error(`Error processing schedule ${schedule.id}:`, error);
        await markScheduleRun(schedule.id, false, errorMessage);
        results.push({
          scheduleId: schedule.id,
          success: false,
          error: errorMessage,
        });
      }
    }

    await releaseLock();

    const successful = results.filter((r) => r.success).length;
    const failed = results.filter((r) => !r.success).length;

    return NextResponse.json({
      message: `Processed ${dueSchedules.length} schedules`,
      processed: dueSchedules.length,
      successful,
      failed,
      results,
    });
  } catch (error) {
    console.error("Error processing reports:", error);
    await releaseLock();
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

// Also support POST for flexibility
export async function POST(request: Request) {
  return GET(request);
}
